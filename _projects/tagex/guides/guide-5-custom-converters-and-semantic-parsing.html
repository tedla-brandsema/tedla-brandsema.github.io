---
layout: default
type: guide
published: 2026-01-18T04:23:49+01:00
author: Tedla Brandsema
heading: Custom Converters and Semantic Parsing
intro: Implement directive-specific parameter parsing so tag values can represent domain semantics.
---

{% include nav-tagex.html %}

<main>
  <h1>{{ page.heading }}</h1>

  <p>
    So far, we have treated directive parameters as simple values:
    numbers, strings, booleans.
  </p>

  <p>
    In this guide, we make an important shift:
    <strong>parameters are not values — they are domain literals</strong>.
  </p>

  <p>
    Tagex embraces this by letting each directive define
    <em>how its own parameters are parsed</em>.
  </p>

  <section class="divider">
    <h2>The Problem: One Type, Many Meanings</h2>

    <p>
      Consider the following struct:
    </p>

    <pre><code class="language-go">
type Limits struct {
    MaxSize   int64 `units:"bytes, max=10MiB"`
    TimeoutMs int64 `units:"duration, value=250ms"`
}
</code></pre>

    <p>
      Both parameters:
    </p>

    <ul>
      <li>Start as raw strings (<code>"10MiB"</code>, <code>"250ms"</code>)</li>
      <li>End up as <code>int64</code></li>
    </ul>

    <p>
      But they clearly do <em>not</em> share a grammar.
    </p>

    <p>
      Parsing these values with a shared, type-based converter
      would require:
    </p>

    <ul>
      <li>Guessing intent</li>
      <li>Branching on directive names</li>
      <li>Hidden coupling between unrelated semantics</li>
    </ul>

    <p>
      Tagex avoids this entirely by making parsing
      a responsibility of the directive itself.
    </p>
  </section>

  <section class="divider">
    <h2>Directive-Owned Parameter Parsing</h2>

    <p>
      A directive may implement custom parameter parsing
      by providing a <code>ConvertParam</code> method.
    </p>

    <p>
      This method receives:
    </p>

    <ul>
      <li>The directive parameter field</li>
      <li>The raw string from the tag</li>
      <li>The destination value to populate</li>
    </ul>

    <p>
      Nothing is inferred.
      Nothing is shared.
      Meaning stays local.
    </p>
  </section>

  <section class="divider">
    <h2>Example: Parsing Byte Sizes</h2>

    <pre><code class="language-go">
type BytesDirective struct {
    Max int64 `param:"max"`
}

func (d *BytesDirective) Name() string { return "bytes" }
func (d *BytesDirective) Mode() tagex.DirectiveMode { return tagex.EvalMode }

func (d *BytesDirective) ConvertParam(
    field reflect.StructField,
    fieldValue reflect.Value,
    raw string,
) error {
    if field.Name != "Max" {
        return nil
    }

    n, err := parseBytes(raw) // "10MiB", "512KiB"
    if err != nil {
        return tagex.NewConversionError(field, raw, "int64")
    }

    fieldValue.SetInt(n)
    return nil
}
</code></pre>

    <p>
      The grammar (<code>MiB</code>, <code>KiB</code>, etc.)
      is owned entirely by the <code>bytes</code> directive.
    </p>
  </section>

  <section class="divider">
    <h2>Example: Parsing Durations</h2>

    <pre><code class="language-go">
type DurationDirective struct {
    Value int64 `param:"value"`
}

func (d *DurationDirective) Name() string { return "duration" }
func (d *DurationDirective) Mode() tagex.DirectiveMode { return tagex.EvalMode }

func (d *DurationDirective) ConvertParam(
    field reflect.StructField,
    fieldValue reflect.Value,
    raw string,
) error {
    if field.Name != "Value" {
        return nil
    }

    dur, err := time.ParseDuration(raw)
    if err != nil {
        return tagex.NewConversionError(field, raw, "int64")
    }

    fieldValue.SetInt(int64(dur / time.Millisecond))
    return nil
}
</code></pre>

    <p>
      This directive parses a completely different grammar,
      even though it writes to the same Go type.
    </p>
  </section>

  <section class="divider">
    <h2>Why This Design Matters</h2>

    <p>
      By making directives responsible for parsing:
    </p>

    <ul>
      <li>Each directive defines its own literal language</li>
      <li>No global or tag-level logic needs to guess intent</li>
      <li>Multiple directives can coexist safely</li>
      <li>Documentation and code stay aligned</li>
    </ul>

    <p>
      Parsing becomes part of semantics —
      not infrastructure.
    </p>
  </section>

  <section class="divider">
    <h2>Default Behavior Still Exists</h2>

    <p>
      Directives that do not implement custom parsing
      automatically fall back to Tagex’s default behavior
      for primitive types.
    </p>

    <p>
      You only pay for complexity when you need it.
    </p>
  </section>

  <section class="divider">
    <h2>The Bigger Picture</h2>

    <p>
      With directive-owned conversion, Tagex now supports:
    </p>

    <ul>
      <li>Human-readable configuration</li>
      <li>Domain-specific literals</li>
      <li>Multiple grammars for the same Go type</li>
      <li>Strict semantic locality</li>
    </ul>

    <p>
      This completes the core model:
    </p>

    <ul>
      <li>Tags select semantics</li>
      <li>Directives define meaning</li>
      <li>Parsing is part of that meaning</li>
    </ul>
  </section>

  <section class="divider">
    <h2>Where to Go Next</h2>

    <p>
      At this point, you have seen the full expressive range of Tagex:
      behavior, capability, success boundaries, validation, and parsing.
    </p>

    <p>
      The remaining work is composition —
      building your own directive libraries
      and letting tags speak your domain’s language.
    </p>
  </section>
</main>
