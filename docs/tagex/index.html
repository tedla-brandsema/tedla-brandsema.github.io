---
layout: default
title: Tagex — Overview
---

{% include nav-tagex.html %}

<main>
  <h1>Tagex</h1>

  <p>
    Tagex is a Go library for executing behavior defined by struct tags.
    It lets you attach <strong>evaluation</strong>, <strong>mutation</strong>,
    and side effects directly to data structures in a controlled and reusable way.
  </p>

  <p>
    Instead of treating struct tags as passive metadata,
    Tagex treats them as instructions:
    tags select <em>what should run</em>,
    directives define <em>what it does</em>,
    and the struct defines <em>what success means</em>.
  </p>

  <section class="divider">
    <h2>What problem does Tagex solve?</h2>

    <p>
      In many Go codebases, structs represent more than just data.
      They describe inputs, configuration, requests, and operational boundaries.
    </p>

    <p>
      The logic associated with those structs is often scattered:
    </p>

    <ul>
      <li>Fields are checked in one place</li>
      <li>Values are modified in another</li>
      <li>Side effects are triggered manually</li>
      <li>Control flow is enforced with ad-hoc conditionals</li>
    </ul>

    <p>
      Tagex provides a way to bring this logic back to where it belongs:
      <strong>next to the data it applies to</strong>,
      without turning structs into active objects or introducing a framework.
    </p>
  </section>

  <section class="divider">
    <h2>Core concepts</h2>

    <h3>Tags</h3>
    <p>
      A <strong>tag</strong> defines an execution context.
      It groups related directives and determines when they apply.
    </p>

    <p>
      Tags are reusable across structs and intentionally lightweight.
      They do not define behavior on their own.
    </p>

    <h3>Directives</h3>
    <p>
      A <strong>directive</strong> is a unit of behavior.
      It may evaluate a field, mutate it, or interpret parameters attached to it.
    </p>

    <p>
      Directives are reusable, composable, and explicitly scoped.
      They define their own semantics, including how their parameters are parsed.
    </p>

    <h3>Structs</h3>
    <p>
      The struct being processed defines intent.
    </p>

    <p>
      It selects which tags apply, which directives run,
      and how the outcome of execution is handled.
    </p>
  </section>

  <section class="divider">
    <h2>Execution model</h2>

    <p>
      Tagex operates as a small, explicit execution engine.
      Processing always starts by calling <code>ProcessStruct</code>
      with a pointer to a struct.
    </p>

    <p>
      During execution:
    </p>

    <ul>
      <li>Struct fields are inspected for matching tags</li>
      <li>Directives are selected based on tag contents</li>
      <li>Each directive executes directly against its field</li>
    </ul>

    <p>
      There is no intermediate representation, rule tree, or expression graph.
      Execution happens directly and deterministically.
    </p>

    <figure class="diagram">
      <img src="/static/images/tagex-lifecycle.png"
        alt="Tagex execution model showing struct-owned lifecycle with optional Before, Success, and Failure hooks around ProcessStruct" />
      <figcaption>
        Tagex execution model: directives run inside <code>ProcessStruct</code>,
        with optional struct-owned lifecycle hooks.
      </figcaption>
    </figure>
  </section>

  <section class="divider">
    <h2>Optional lifecycle hooks</h2>

    <p>
      A struct may optionally define lifecycle hooks that are invoked
      before and after directive execution.
    </p>

    <p>
      These hooks are <strong>struct-owned</strong> and entirely optional.
      Tagex does not interpret their meaning or enforce semantics.
    </p>

    <ul>
      <li>
        <strong>Before()</strong> — runs before directive execution begins
      </li>
      <li>
        <strong>Success()</strong> — runs after all directives complete successfully
      </li>
      <li>
        <strong>Failure(err)</strong> — runs if execution fails at any point
      </li>
    </ul>

    <p>
      This allows the same tags and directives to be reused across structs,
      while each struct defines its own success and failure boundaries.
    </p>
  </section>

  <section class="divider">
    <h2>Execution, not interpretation</h2>

    <p>
      Tagex does not interpret intent or infer meaning.
      It executes exactly what is declared.
    </p>

    <p>
      Execution is:
    </p>

    <ul>
      <li>Explicit</li>
      <li>Deterministic</li>
      <li>Locally scoped</li>
    </ul>

    <p>
      There is no global state, no hidden lifecycle,
      and no implicit ordering beyond what is declared.
      Tagex is a small execution model that makes struct-attached behavior
      explicit, reusable, and predictable.
    </p>
  </section>


  <section class="divider">
    <h2>Next steps</h2>

    <p>
      To see Tagex in action, start with the
      <a href="getting-started.html">Getting started</a> guide.
    </p>

    <p>
      The <a href="guides/">Guides</a> section explores the model in depth,
      including evaluation, mutation,
      pre- and post-processing, and directive-owned parsing.
    </p>
  </section>
</main>